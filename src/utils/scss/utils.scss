@use "@angular/material" as mat;

@function generate-selector-list($args...) {
  $selector: null;
  /* Percorrendo pelos lista de seletores */
  @each $class in $args {
    /* Transformando a lista de seletores em um unico seletor */
    @if $selector == null {
      $selector: $class;
    } @else {
      $selector: $selector + ", " + $class;
    }
  }
  /* Retornando resultado do seletor */
  @return $selector;
}

@function custom-color-mix($color1, $percent1, $color2, $percent2) {
  @return color-mix(in srgb, $color1 $percent1, $color2 $percent2);
}

@mixin angularMaterial($theme) {
  $primary: none;
  $accent: none;
  $warn: none;
  $error: none;
  @if mat.get-theme-type($theme) == dark {
    $primary: mat.get-theme-color($theme, primary, default);
    $accent: mat.get-theme-color($theme, accent, default);
    $warn: mat.get-theme-color($theme, warn, default);
  } @else {
    $primary: mat.get-theme-color($theme, primary, default);
    $accent: mat.get-theme-color($theme, accent, default);
    $warn: mat.get-theme-color($theme, warn, default);
  }

  mat-icon {
    transition: transform 0.2s;
    &:hover{
      transform: scale(1.3);
    }
    &:focus{
      outline: none;
      fill   : $primary;
      color  : $primary;
    }
    &:active{
      fill : $accent;
      color: $accent;
    }
  }
}

@mixin stickyStructure() {
  [sticky] {
    z-index: 1;
    position: sticky;
    padding: 5px;
    top: 0;
    &::after {
      content: "";
      position: absolute;
      inset: 0;
      z-index: -1;
      border-radius: 5px;
      background: rgba(0, 0, 0, 0.3);
      mask: linear-gradient(to top, transparent, black 50%);
      backdrop-filter: blur(3px);
    }

    &[sticky~="bottom"] {
      mask: linear-gradient(to bottom, transparent, black 50%);
      top: auto;
      bottom: 0;
    }
    &[sticky~="left"] {
      mask: linear-gradient(to left, transparent, black 50%);
      top: auto;
      left: 0;
    }
    &[sticky~="right"] {
      mask: linear-gradient(to right, transparent, black 50%);
      top: auto;
      right: 0;
    }
  }
}

@mixin padStructure($default) {
  [pad~="all"] {
    padding: $default;
  }

  [pad~="bottom"],
  [pad~="bt"] {
    padding-bottom: $default;
  }
  [pad~="top"],
  [pad~="tp"] {
    padding-top: $default;
  }
  [pad~="left"],
  [pad~="lt"] {
    padding-left: $default;
  }
  [pad~="right"],
  [pad~="rt"] {
    padding-right: $default;
  }

  @for $i from 0 through 20 {
    [pad~="#{$i}"] {
      &[pad~="all"]{
        padding: #{$i}px;
      }
      
      &[pad~="bottom"],
      &[pad~="bt"] {
        padding-bottom: #{$i}px;
      }
      &[pad~="top"],
      &[pad~="tp"] {
        padding-top: #{$i}px;
      }
      &[pad~="left"],
      &[pad~="lt"] {
        padding-left: #{$i}px;
      }
      &[pad~="right"],
      &[pad~="rt"] {
        padding-right: #{$i}px;
      }
    }
  }
}

/*
  - [flex] (<div flex="*">)
    slow      | slw   - transition flex-basis 1s (transição de 1s)
    very-slow | v-slw - transition flex-basis 2s (transição de 2s)
    row       | r     - row flow        (Altera o corpotamento de flex para linha)
    on        |       - habilitar flex  (Utilizado em flex dentro de outro flex) 
    center    | c     - elemento centralizado
    v-center  | vc    - elemento centralizado (Vertical apenas)
    h-center  | hc    - elemento centralizado (Horizontal apenas)
    right     | rt    - elemento para direita
    border    | b     - borda no elemento
    grow      | g     - permite que o elemento cresça o tamanho maior que o citado.
    shrink    | s     - permite que o elemento dimunua o tamanho menor que o citado.
    no-shrink | ns    - impede que o elemento dimunua o tamanho menor que o citado.
      aplicado automaticamente em: (scl-y > scl-x), (scl-x -> scl-y)
    no-scroll | nscl  - desativa o scroll (visible)
    scroll    | scl   - habilita scroll
    scroll-y  | scl-y - habilita apenas scroll-y
    scroll-x  | scl-x - habilita apenas scroll-x
    hide      | hid   - permite que seja possivel esconder o elemento
    [gap] (<div flex="*" gap="n* direction*">)
      n* - tamanho do espaçamento
      direction* - direção aplicada do espaçamento (row/col) Opcional
      Ex: (gap="10 row"), (gap="8")
 */
@mixin flexStructure($defaultGap) {
  * {
    &:not([flex] > [flex]) {
      &[flex] {
        display: flex;

        overflow-x: auto;
        overflow-y: hidden;
      }
    }
  }
  [flex]{
    // min-width: fit-content; 
    // min-height: fit-content;

    column-gap: $defaultGap;
    row-gap: $defaultGap;
    // transition: flex-basis 0.5s, width 0.5s, height 0.5s;
    transition: max-width 0.5s, max-height 0.5s ;
    text-wrap: nowrap;
  }

  :is(
    [flex~="on"]
   ) {
    display: flex;
    overflow-x: auto;
    overflow-y: hidden;
  }

  :is(
    [flex~="row"],
    [flex~="r"]
  ) {
    flex-flow: column;

    overflow-y: auto;
    overflow-x: hidden;
  }
  
  :is(
    [flex~="grow"],
    [flex~="g"]
  ) {
    flex-grow: 1;
  }

  :is(
    [flex~="shrink"],
    [flex~="s"]
  ) {
    flex-shrink: 1;
  }

  :is(
    [flex~="no-shrink"],
    [flex~="ns"]
  ) {
    flex-shrink: 0;
  }

  :is(
    [flex~="no-scroll"],
    [flex~="nscl"]
  ){
    overflow: visible;
  }

  :is(
    [flex~="center"],
    [flex~="c"]
   ) {
    margin: auto;
  }

  :is(
    [flex~="v-center"],
    [flex~="vc"]
  ) {
    margin-top: auto;
    margin-bottom: auto;
  }

  :is(
    [flex~="h-center"],
    [flex~="hc"] 
  ) {
    margin-left: auto;
    margin-right: auto;
  }

  :is(
    [flex~="border"],
    [flex~="b"] 
  ) {
    border: 1px solid;
    border-radius: 10px;
    padding: $defaultGap;
  }

  @for $i from 0 through 100 {
    $pct: percentage(calc($i/100));
    
    :not([flex] > [flex]) {
      &[flex~="row"], 
      &[flex~="r"] {
        &[flex~="#{$i}"] {
          height: $pct;
        }
      }
    }

    :not([flex~="row"]):not([flex~="r"])[flex~="#{$i}"] {
      max-width: $pct;
      &[flex~="no-scroll"],
      &[flex~="nscl"]{
        overflow: hidden;
      }
    }
    
    :is(
      [flex~="row"],
      [flex~="r"]
    ) > [flex~="f#{$i}"] {
      max-height: $pct;
    }
  }
}

// #{generate-selector-list(
//   '.grid',
//   '.grid-col',
//   '.grid-row',
//   '.grid-dense')} {
//     *{
//       transition: all 1s;
//     }
//     display: grid;
//     $sizes: auto, 0fr, 1fr, min-content, max-content;
//     $attrsValues: 'auto', '0fr', '1fr', 'min', 'max';
//     @include generate-grid(100, 12, $sizes, $attrsValues);
// }